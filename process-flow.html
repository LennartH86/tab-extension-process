<!-- process-flow.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Flow Extension</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="./lib/tableau.extensions.1.latest.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: white;
        }

        .toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .toolbar button {
            background: none;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .toolbar button:hover {
            background: #f8f9fa;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .zoom-level {
            min-width: 50px;
            text-align: center;
            font-size: 11px;
            color: #666;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .process-node-group {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .process-node-group:hover {
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }

        .connection-line {
            fill: none;
            stroke-width: 2;
            transition: stroke-width 0.3s ease;
        }

        .connection-line.success {
            stroke: #28a745;
            marker-end: url(#arrowhead-success);
        }

        .connection-line.failure {
            stroke: #dc3545;
            stroke-dasharray: 8,4;
            marker-end: url(#arrowhead-failure);
        }

        .connection-line.continuation {
            stroke: #ffc107;
            stroke-dasharray: 4,4;
            marker-end: url(#arrowhead-continuation);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            max-width: 400px;
            text-align: center;
        }

        .configure-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            max-width: 400px;
        }

        .configure-prompt h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .configure-prompt p {
            margin-bottom: 20px;
            color: #666;
            line-height: 1.5;
        }

        .configure-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .configure-btn:hover {
            background: #0052a3;
        }

        .node-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 2000;
            display: none;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="loading" id="loading">Initializing extension...</div>
        
        <div class="configure-prompt" id="configurePrompt" style="display: none;">
            <h3>üîß Configuration Required</h3>
            <p>Please configure the extension to select the worksheet containing your process data.</p>
            <button class="configure-btn" onclick="openConfigureDialog()">Configure Extension</button>
        </div>
        
        <div class="toolbar" id="toolbar" style="display: none;">
            <button onclick="resetView()">üè†</button>
            <div class="zoom-controls">
                <button onclick="zoomOut()">‚àí</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button onclick="zoomIn()">+</button>
            </div>
            <button onclick="refreshData()">üîÑ</button>
            <button onclick="openConfigureDialog()">‚öôÔ∏è</button>
        </div>
        
        <svg id="canvas" viewBox="0 0 1000 800" style="display: none;">
            <defs>
                <marker id="arrowhead-success" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#28a745" />
                </marker>
                <marker id="arrowhead-failure" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#dc3545" />
                </marker>
                <marker id="arrowhead-continuation" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#ffc107" />
                </marker>
            </defs>
        </svg>
        
        <div class="node-tooltip" id="tooltip"></div>
    </div>

    <script>
        let currentZoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };
        let processData = [];
        let dashboard;
        let selectedWorksheet = null;

        $(document).ready(function() {
            console.log('Document ready, initializing extension...');
            
            // Check if tableau object exists
            if (typeof tableau === 'undefined') {
                showError('Tableau Extensions API not loaded. Please ensure you are running this from within Tableau.');
                return;
            }

            // Initialize with configuration callback
            tableau.extensions.initializeAsync({ 'configure': configure }).then(function() {
                console.log('Extension initialized successfully');
                dashboard = tableau.extensions.dashboardContent.dashboard;
                
                // Check if extension is already configured
                const worksheetName = tableau.extensions.settings.get('selectedWorksheet');
                console.log('Saved worksheet name:', worksheetName);
                
                if (worksheetName) {
                    selectedWorksheet = dashboard.worksheets.find(ws => ws.name === worksheetName);
                    if (selectedWorksheet) {
                        console.log('Found worksheet, loading data...');
                        loadProcessData();
                    } else {
                        console.log('Worksheet not found, showing configure prompt');
                        showConfigurePrompt();
                    }
                } else {
                    console.log('No worksheet configured, showing configure prompt');
                    showConfigurePrompt();
                }
            }, function(err) {
                console.error('Initialization error:', err);
                showError('Error initializing extension: ' + err.toString());
            });
        });

        function configure() {
            openConfigureDialog();
        }

        function openConfigureDialog() {
            console.log('Opening configuration dialog...');
            // Use the same origin as the main extension, not window.location.origin
            const popupUrl = `https://lennarth86.github.io/tab-extension-process/process-flow-config.html`;
            console.log('Dialog URL:', popupUrl);
            
            // Get current settings
            const currentSettings = {
                selectedWorksheet: tableau.extensions.settings.get('selectedWorksheet') || '',
                timestampColumn: tableau.extensions.settings.get('timestampColumn') || '',
                idColumn: tableau.extensions.settings.get('idColumn') || '',
                processColumn: tableau.extensions.settings.get('processColumn') || '',
                statusColumn: tableau.extensions.settings.get('statusColumn') || ''
            };

            console.log('Current settings:', currentSettings);

            tableau.extensions.ui.displayDialogAsync(popupUrl, JSON.stringify(currentSettings), { 
                height: 600, 
                width: 500 
            }).then((closePayload) => {
                console.log('Dialog closed with payload:', closePayload);
                if (closePayload && closePayload !== 'cancelled') {
                    // Save settings and reload data
                    tableau.extensions.settings.saveAsync().then(() => {
                        console.log('Settings saved, reloading data...');
                        const worksheetName = tableau.extensions.settings.get('selectedWorksheet');
                        selectedWorksheet = dashboard.worksheets.find(ws => ws.name === worksheetName);
                        if (selectedWorksheet) {
                            loadProcessData();
                        }
                    });
                }
            }).catch((error) => {
                console.error('Configuration dialog error:', error);
                showError('Error opening configuration dialog: ' + error.toString());
            });
        }

        function showConfigurePrompt() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('configurePrompt').style.display = 'block';
        }

        function loadProcessData() {
            try {
                document.getElementById('configurePrompt').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Loading process data...';

                if (!selectedWorksheet) {
                    showError('No worksheet selected. Please configure the extension.');
                    return;
                }

                // Get data from the selected worksheet
                selectedWorksheet.getSummaryDataAsync().then(function(dataTable) {
                    parseTableauData(dataTable);
                    renderDiagram();
                    hideLoading();
                }).catch(function(err) {
                    showError('Error loading data from worksheet: ' + err.toString());
                });

            } catch(err) {
                showError('Error loading data: ' + err.toString());
            }
        }

        function parseTableauData(dataTable) {
            const data = [];
            const columns = dataTable.columns;
            
            // Get column settings from configuration
            const timestampColName = tableau.extensions.settings.get('timestampColumn');
            const idColName = tableau.extensions.settings.get('idColumn');
            const processColName = tableau.extensions.settings.get('processColumn');
            const statusColName = tableau.extensions.settings.get('statusColumn');

            // Find columns by configured names or fallback to auto-detection
            const timestampCol = columns.find(col => 
                col.fieldName === timestampColName || 
                col.fieldName.toLowerCase().includes('timestamp') ||
                col.fieldName.toLowerCase().includes('time')
            );
            const idCol = columns.find(col => 
                col.fieldName === idColName || 
                col.fieldName.toLowerCase().includes('id')
            );
            const processCol = columns.find(col => 
                col.fieldName === processColName || 
                col.fieldName.toLowerCase().includes('process') ||
                col.fieldName.toLowerCase().includes('step')
            );
            const statusCol = columns.find(col => 
                col.fieldName === statusColName || 
                col.fieldName.toLowerCase().includes('status')
            );

            if (!timestampCol || !idCol || !processCol) {
                showError('Required columns not found. Please configure the extension with the correct column names.');
                return;
            }

            // Parse data
            dataTable.data.forEach(row => {
                const rowData = {
                    timestamp: row[timestampCol.index].value,
                    id: row[idCol.index].value,
                    process: row[processCol.index].value,
                    status: statusCol ? (row[statusCol.index].value || 'success') : 'success'
                };
                data.push(rowData);
            });

            // Process the data to create process steps
            processData = analyzeProcessData(data);
        }

        function analyzeProcessData(data) {
            // Get unique process names in order of first appearance
            const processOrder = [];
            const seenProcesses = new Set();
            
            data.forEach(row => {
                if (!seenProcesses.has(row.process)) {
                    processOrder.push(row.process);
                    seenProcesses.add(row.process);
                }
            });

            const processSteps = {};
            
            // Analyze sessions first to get total runs and successful runs
            const sessions = {};
            data.forEach(row => {
                if (!sessions[row.id]) {
                    sessions[row.id] = {};
                }
                sessions[row.id][row.process] = row.status;
            });

            // Count total runs and fully successful runs
            const totalRuns = Object.keys(sessions).length;
            let fullySuccessfulRuns = 0;

            Object.values(sessions).forEach(session => {
                let hasAnyFailure = false;
                processOrder.forEach(step => {
                    if (session[step] && (session[step] === 'failed' || session[step] === 'failure')) {
                        hasAnyFailure = true;
                    }
                });
                if (!hasAnyFailure) {
                    fullySuccessfulRuns++;
                }
            });
            
            // Initialize process steps - all get the same 'normal' type now
            processOrder.forEach((step, index) => {
                const displayName = step.charAt(0).toUpperCase() + 
                    step.slice(1).replace(/([A-Z])/g, ' $1');
                
                processSteps[step] = {
                    id: step,
                    title: displayName,
                    successCount: 0,
                    failureCount: 0,
                    x: 300,
                    y: 200 + (index * 130), // Moved down to make room for start element
                    type: 'normal' // All process steps get same color
                };
            });

            // Count successes and failures by session
            Object.values(sessions).forEach(session => {
                processOrder.forEach(step => {
                    if (session[step]) {
                        if (session[step] === 'failed' || session[step] === 'failure') {
                            processSteps[step].failureCount++;
                        } else {
                            processSteps[step].successCount++;
                        }
                    }
                });
            });

            // Create array with start element, main steps, failure nodes, and success element
            const allSteps = [];
            
            // Add start element
            allSteps.push({
                id: 'start',
                title: 'Process Start',
                successCount: totalRuns,
                failureCount: 0,
                x: 300,
                y: 70,
                type: 'start'
            });

            // Add main process steps and their failure nodes
            processOrder.forEach(step => {
                allSteps.push(processSteps[step]);
                if (processSteps[step].failureCount > 0) {
                    allSteps.push({
                        id: step + '-failed',
                        title: processSteps[step].title + ' Failed',
                        successCount: 0,
                        failureCount: processSteps[step].failureCount,
                        x: 550,
                        y: processSteps[step].y,
                        type: 'failure'
                    });
                }
            });

            // Add success element at the end
            const lastY = processOrder.length > 0 ? 200 + ((processOrder.length - 1) * 130) + 130 : 330;
            allSteps.push({
                id: 'success',
                title: 'Process Success',
                successCount: fullySuccessfulRuns,
                failureCount: 0,
                x: 300,
                y: lastY,
                type: 'end'
            });

            return allSteps;
        }

        function renderDiagram() {
            const canvas = document.getElementById('canvas');
            // Clear previous content but keep defs
            const defs = canvas.querySelector('defs');
            canvas.innerHTML = '';
            canvas.appendChild(defs);
            
            createConnections();
            
            processData.forEach(node => {
                createProcessNode(node);
            });

            setupPanZoom();
        }

        function createConnections() {
            const canvas = document.getElementById('canvas');
            
            // Get main process steps (excluding failure nodes, start, and success)
            const mainSteps = processData.filter(n => 
                !n.id.includes('-failed') && n.id !== 'start' && n.id !== 'success'
            );
            const startNode = processData.find(n => n.id === 'start');
            const successNode = processData.find(n => n.id === 'success');
            
            // Connection from start to first main step
            if (startNode && mainSteps.length > 0) {
                createConnectionLine(startNode, mainSteps[0], 'success');
            }
            
            // Main flow connections between process steps
            for (let i = 0; i < mainSteps.length - 1; i++) {
                createConnectionLine(mainSteps[i], mainSteps[i + 1], 'success');
            }
            
            // Connection from last main step to success
            if (mainSteps.length > 0 && successNode) {
                createConnectionLine(mainSteps[mainSteps.length - 1], successNode, 'success');
            }

            // Failure and continuation connections
            mainSteps.forEach((step, index) => {
                const failNode = processData.find(n => n.id === step.id + '-failed');
                
                if (failNode) {
                    // Connection to failure
                    createConnectionLine(step, failNode, 'failure');
                    
                    // Continuation to next step if it exists
                    if (index < mainSteps.length - 1) {
                        createConnectionLine(failNode, mainSteps[index + 1], 'continuation', failNode.failureCount);
                    } else {
                        // If it's the last step, continue to success node
                        if (successNode) {
                            createConnectionLine(failNode, successNode, 'continuation', failNode.failureCount);
                        }
                    }
                }
            });
        }

        function createConnectionLine(fromNode, toNode, type, count = null) {
            const canvas = document.getElementById('canvas');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            let pathData;
            if (type === 'failure') {
                pathData = `M ${fromNode.x + 45} ${fromNode.y} L ${toNode.x - 45} ${toNode.y}`;
            } else if (type === 'continuation') {
                const midX = (fromNode.x + toNode.x) / 2;
                const curveY = fromNode.y + 40;
                pathData = `M ${fromNode.x} ${fromNode.y + 45} Q ${midX} ${curveY} ${toNode.x - 45} ${toNode.y}`;
                
                // Add count label for continuation lines
                if (count && count > 0) {
                    const labelX = midX;
                    const labelY = curveY;
                    
                    const countLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    countLabel.setAttribute('x', labelX);
                    countLabel.setAttribute('y', labelY);
                    countLabel.setAttribute('text-anchor', 'middle');
                    countLabel.setAttribute('font-size', '10');
                    countLabel.setAttribute('font-weight', '600');
                    countLabel.setAttribute('fill', '#ffc107');
                    countLabel.textContent = count.toString();
                    
                    // Add background circle for better readability
                    const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    labelBg.setAttribute('cx', labelX);
                    labelBg.setAttribute('cy', labelY - 3);
                    labelBg.setAttribute('r', '12');
                    labelBg.setAttribute('fill', 'white');
                    labelBg.setAttribute('stroke', '#ffc107');
                    labelBg.setAttribute('stroke-width', '2');
                    
                    canvas.appendChild(labelBg);
                    canvas.appendChild(countLabel);
                }
            } else {
                pathData = `M ${fromNode.x} ${fromNode.y + 45} L ${toNode.x} ${toNode.y - 45}`;
            }
            
            path.setAttribute('d', pathData);
            path.setAttribute('class', `connection-line ${type}`);
            canvas.appendChild(path);
        }

        function createProcessNode(node) {
            const canvas = document.getElementById('canvas');
            
            const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nodeGroup.setAttribute('class', 'process-node-group');
            nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '0');
            circle.setAttribute('cy', '0');
            circle.setAttribute('r', '45');
            
            let fillColor = 'white';
            let strokeColor = '#007bff';
            
            switch(node.type) {
                case 'start':
                    fillColor = '#17a2b8';
                    strokeColor = '#17a2b8';
                    break;
                case 'failure':
                    fillColor = '#dc3545';
                    strokeColor = '#dc3545';
                    break;
                case 'end':
                    fillColor = '#28a745';
                    strokeColor = '#28a745';
                    break;
                case 'normal':
                    // All process steps get the same blue color
                    fillColor = 'white';
                    strokeColor = '#007bff';
                    break;
            }
            
            circle.setAttribute('fill', fillColor);
            circle.setAttribute('stroke', strokeColor);
            circle.setAttribute('stroke-width', '3');
            
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', '0');
            title.setAttribute('y', '-8');
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '10');
            title.setAttribute('font-weight', '600');
            title.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#333');
            
            // Split long titles into multiple lines
            const words = node.title.split(' ');
            if (words.length > 2) {
                title.setAttribute('y', '-15');
                title.textContent = words.slice(0, 2).join(' ');
                
                const title2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title2.setAttribute('x', '0');
                title2.setAttribute('y', '-5');
                title2.setAttribute('text-anchor', 'middle');
                title2.setAttribute('font-size', '10');
                title2.setAttribute('font-weight', '600');
                title2.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#333');
                title2.textContent = words.slice(2).join(' ');
                nodeGroup.appendChild(title2);
            } else {
                title.textContent = node.title;
            }
            
            const count = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            count.setAttribute('x', '0');
            count.setAttribute('y', '6');
            count.setAttribute('text-anchor', 'middle');
            count.setAttribute('font-size', '9');
            count.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#666');
            
            if (node.type === 'failure') {
                count.textContent = `${node.failureCount} failed`;
            } else if (node.failureCount > 0) {
                count.textContent = `${node.successCount}/${node.successCount + node.failureCount}`;
            } else {
                count.textContent = node.successCount.toString();
            }
            
            nodeGroup.appendChild(circle);
            nodeGroup.appendChild(title);
            nodeGroup.appendChild(count);
            
            nodeGroup.addEventListener('mouseenter', (e) => showTooltip(e, node));
            nodeGroup.addEventListener('mouseleave', hideTooltip);
            
            canvas.appendChild(nodeGroup);
        }

        function showTooltip(e, node) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY - 10 + 'px';
            
            let content = `<strong>${node.title}</strong><br>`;
            content += `Success: ${node.successCount}<br>`;
            if (node.failureCount > 0) {
                content += `Failures: ${node.failureCount}<br>`;
                const total = node.successCount + node.failureCount;
                const rate = ((node.successCount / total) * 100).toFixed(1);
                content += `Success Rate: ${rate}%`;
            }
            
            tooltip.innerHTML = content;
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function setupPanZoom() {
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', pan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);
            canvas.addEventListener('wheel', zoom);
        }

        function startPan(e) {
            if (e.target.closest('.process-node-group')) return;
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY };
        }

        function pan(e) {
            if (!isPanning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            panOffset.x += dx;
            panOffset.y += dy;
            updateTransform();
            panStart = { x: e.clientX, y: e.clientY };
        }

        function endPan() {
            isPanning = false;
        }

        function zoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            currentZoom *= delta;
            currentZoom = Math.max(0.3, Math.min(3, currentZoom));
            updateZoomLevel();
            updateTransform();
        }

        function zoomIn() {
            currentZoom *= 1.2;
            currentZoom = Math.min(3, currentZoom);
            updateZoomLevel();
            updateTransform();
        }

        function zoomOut() {
            currentZoom *= 0.8;
            currentZoom = Math.max(0.3, currentZoom);
            updateZoomLevel();
            updateTransform();
        }

        function resetView() {
            currentZoom = 1;
            panOffset = { x: 0, y: 0 };
            updateZoomLevel();
            updateTransform();
        }

        function updateZoomLevel() {
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            const viewBox = `${-panOffset.x / currentZoom} ${-panOffset.y / currentZoom} ${1000 / currentZoom} ${800 / currentZoom}`;
            canvas.setAttribute('viewBox', viewBox);
        }

        function refreshData() {
            if (selectedWorksheet) {
                loadProcessData();
            }
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('canvas').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex';
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('configurePrompt').style.display = 'none';
            document.getElementById('canvas').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `<strong>Error:</strong><br>${message}`;
            document.querySelector('.container').appendChild(errorDiv);
        }
    </script>
</body>
</html>