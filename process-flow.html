<!-- process-flow.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Flow Extension</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://tableau.github.io/extensions-api/lib/tableau.extensions.1.latest.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: white;
        }

        .toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .toolbar button {
            background: none;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .toolbar button:hover {
            background: #f8f9fa;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .zoom-level {
            min-width: 50px;
            text-align: center;
            font-size: 11px;
            color: #666;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .process-node-group {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .process-node-group:hover {
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }

        .connection-line {
            fill: none;
            stroke-width: 2;
            transition: stroke-width 0.3s ease;
        }

        .connection-line.success {
            stroke: #28a745;
            marker-end: url(#arrowhead-success);
        }

        .connection-line.failure {
            stroke: #dc3545;
            stroke-dasharray: 8,4;
            marker-end: url(#arrowhead-failure);
        }

        .connection-line.continuation {
            stroke: #ffc107;
            stroke-dasharray: 4,4;
            marker-end: url(#arrowhead-continuation);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #666;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
        }

        .node-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 2000;
            display: none;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="loading" id="loading">Loading process data...</div>
        
        <div class="toolbar" id="toolbar" style="display: none;">
            <button onclick="resetView()">üè†</button>
            <div class="zoom-controls">
                <button onclick="zoomOut()">‚àí</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button onclick="zoomIn()">+</button>
            </div>
            <button onclick="refreshData()">üîÑ</button>
        </div>
        
        <svg id="canvas" viewBox="0 0 1000 800" style="display: none;">
            <defs>
                <marker id="arrowhead-success" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#28a745" />
                </marker>
                <marker id="arrowhead-failure" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#dc3545" />
                </marker>
                <marker id="arrowhead-continuation" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#ffc107" />
                </marker>
            </defs>
        </svg>
        
        <div class="node-tooltip" id="tooltip"></div>
    </div>

    <script>
        let currentZoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };
        let processData = [];
        let dashboard;

        $(document).ready(function() {
            tableau.extensions.initializeAsync().then(function() {
                dashboard = tableau.extensions.dashboardContent.dashboard;
                loadProcessData();
            }, function(err) {
                showError('Error initializing extension: ' + err.toString());
            });
        });

        function loadProcessData() {
            try {
                // Get the worksheet that contains process data
                const worksheets = dashboard.worksheets;
                const processWorksheet = worksheets.find(ws => 
                    ws.name.toLowerCase().includes('process') || 
                    ws.name.toLowerCase().includes('flow')
                );

                if (!processWorksheet) {
                    showError('No worksheet found with process data. Please ensure you have a worksheet named with "process" or "flow".');
                    return;
                }

                // Get data from the worksheet
                processWorksheet.getSummaryDataAsync().then(function(dataTable) {
                    parseTableauData(dataTable);
                    renderDiagram();
                    hideLoading();
                });

            } catch(err) {
                showError('Error loading data: ' + err.toString());
            }
        }

        function parseTableauData(dataTable) {
            const data = [];
            const columns = dataTable.columns;
            
            // Find required columns
            const timestampCol = columns.find(col => col.fieldName.toLowerCase().includes('timestamp'));
            const idCol = columns.find(col => col.fieldName.toLowerCase().includes('id'));
            const processCol = columns.find(col => col.fieldName.toLowerCase().includes('process'));
            const statusCol = columns.find(col => col.fieldName.toLowerCase().includes('status'));

            if (!timestampCol || !idCol || !processCol) {
                showError('Required columns not found. Please ensure your data has: timestamp, id, process, and optionally status columns.');
                return;
            }

            // Parse data
            dataTable.data.forEach(row => {
                const rowData = {
                    timestamp: row[timestampCol.index].value,
                    id: row[idCol.index].value,
                    process: row[processCol.index].value,
                    status: statusCol ? row[statusCol.index].value : 'success'
                };
                data.push(rowData);
            });

            // Process the data to create process steps
            processData = analyzeProcessData(data);
        }

        function analyzeProcessData(data) {
            const processSteps = {};
            const processOrder = ['calibrate', 'assembleEngine', 'assembleBack', 'assembleBody', 'ejectCar'];
            
            // Initialize process steps
            processOrder.forEach((step, index) => {
                processSteps[step] = {
                    id: step,
                    title: step.charAt(0).toUpperCase() + step.slice(1).replace(/([A-Z])/g, ' $1'),
                    successCount: 0,
                    failureCount: 0,
                    x: 300,
                    y: 150 + (index * 130),
                    type: index === 0 ? 'start' : (index === processOrder.length - 1 ? 'end' : 'normal')
                };
            });

            // Count successes and failures
            const sessions = {};
            data.forEach(row => {
                if (!sessions[row.id]) {
                    sessions[row.id] = {};
                }
                sessions[row.id][row.process] = row.status || 'success';
            });

            // Analyze each session
            Object.values(sessions).forEach(session => {
                processOrder.forEach(step => {
                    if (session[step]) {
                        if (session[step] === 'failed') {
                            processSteps[step].failureCount++;
                        } else {
                            processSteps[step].successCount++;
                        }
                    }
                });
            });

            // Create failure nodes
            const allSteps = [];
            processOrder.forEach(step => {
                allSteps.push(processSteps[step]);
                if (processSteps[step].failureCount > 0) {
                    allSteps.push({
                        id: step + '-failed',
                        title: processSteps[step].title + ' Failed',
                        successCount: 0,
                        failureCount: processSteps[step].failureCount,
                        x: 550,
                        y: processSteps[step].y,
                        type: 'failure'
                    });
                }
            });

            return allSteps;
        }

        function renderDiagram() {
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = canvas.querySelector('defs').outerHTML; // Keep defs
            
            createConnections();
            
            processData.forEach(node => {
                createProcessNode(node);
            });

            setupPanZoom();
        }

        function createConnections() {
            const canvas = document.getElementById('canvas');
            const processOrder = ['calibrate', 'assembleEngine', 'assembleBack', 'assembleBody', 'ejectCar'];
            
            // Main flow connections
            for (let i = 0; i < processOrder.length - 1; i++) {
                const from = processData.find(n => n.id === processOrder[i]);
                const to = processData.find(n => n.id === processOrder[i + 1]);
                createConnectionLine(from, to, 'success');
            }

            // Failure connections
            processOrder.forEach((step, index) => {
                const mainNode = processData.find(n => n.id === step);
                const failNode = processData.find(n => n.id === step + '-failed');
                
                if (failNode) {
                    // Connection to failure
                    createConnectionLine(mainNode, failNode, 'failure');
                    
                    // Continuation to next step if it exists
                    if (index < processOrder.length - 1) {
                        const nextStep = processData.find(n => n.id === processOrder[index + 1]);
                        createConnectionLine(failNode, nextStep, 'continuation');
                    }
                }
            });
        }

        function createConnectionLine(fromNode, toNode, type) {
            const canvas = document.getElementById('canvas');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            let pathData;
            if (type === 'failure') {
                pathData = `M ${fromNode.x + 50} ${fromNode.y} L ${toNode.x - 50} ${toNode.y}`;
            } else if (type === 'continuation') {
                const midX = (fromNode.x + toNode.x) / 2;
                const curveY = fromNode.y + 40;
                pathData = `M ${fromNode.x} ${fromNode.y + 50} Q ${midX} ${curveY} ${toNode.x - 50} ${toNode.y}`;
            } else {
                pathData = `M ${fromNode.x} ${fromNode.y + 50} L ${toNode.x} ${toNode.y - 50}`;
            }
            
            path.setAttribute('d', pathData);
            path.setAttribute('class', `connection-line ${type}`);
            canvas.appendChild(path);
        }

        function createProcessNode(node) {
            const canvas = document.getElementById('canvas');
            
            const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nodeGroup.setAttribute('class', 'process-node-group');
            nodeGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '0');
            circle.setAttribute('cy', '0');
            circle.setAttribute('r', '45');
            
            let fillColor = 'white';
            let strokeColor = '#007bff';
            
            switch(node.type) {
                case 'start':
                    fillColor = '#17a2b8';
                    strokeColor = '#17a2b8';
                    break;
                case 'failure':
                    fillColor = '#dc3545';
                    strokeColor = '#dc3545';
                    break;
                case 'end':
                    fillColor = node.failureCount > 0 ? '#fff3cd' : '#d4edda';
                    strokeColor = node.failureCount > 0 ? '#ffc107' : '#28a745';
                    break;
                case 'normal':
                    if (node.failureCount > 0) {
                        fillColor = '#f8d7da';
                        strokeColor = '#dc3545';
                    } else {
                        fillColor = 'white';
                        strokeColor = '#28a745';
                    }
                    break;
            }
            
            circle.setAttribute('fill', fillColor);
            circle.setAttribute('stroke', strokeColor);
            circle.setAttribute('stroke-width', '3');
            
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', '0');
            title.setAttribute('y', '-8');
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '10');
            title.setAttribute('font-weight', '600');
            title.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#333');
            
            // Split long titles into multiple lines
            const words = node.title.split(' ');
            if (words.length > 2) {
                title.setAttribute('y', '-15');
                title.textContent = words.slice(0, 2).join(' ');
                
                const title2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title2.setAttribute('x', '0');
                title2.setAttribute('y', '-5');
                title2.setAttribute('text-anchor', 'middle');
                title2.setAttribute('font-size', '10');
                title2.setAttribute('font-weight', '600');
                title2.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#333');
                title2.textContent = words.slice(2).join(' ');
                nodeGroup.appendChild(title2);
            } else {
                title.textContent = node.title;
            }
            
            const count = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            count.setAttribute('x', '0');
            count.setAttribute('y', '6');
            count.setAttribute('text-anchor', 'middle');
            count.setAttribute('font-size', '9');
            count.setAttribute('fill', (node.type === 'start' || node.type === 'failure') ? 'white' : '#666');
            
            if (node.type === 'failure') {
                count.textContent = `${node.failureCount} failed`;
            } else if (node.failureCount > 0) {
                count.textContent = `${node.successCount}/${node.successCount + node.failureCount}`;
            } else {
                count.textContent = node.successCount.toString();
            }
            
            nodeGroup.appendChild(circle);
            nodeGroup.appendChild(title);
            nodeGroup.appendChild(count);
            
            nodeGroup.addEventListener('mouseenter', (e) => showTooltip(e, node));
            nodeGroup.addEventListener('mouseleave', hideTooltip);
            
            canvas.appendChild(nodeGroup);
        }

        function showTooltip(e, node) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY - 10 + 'px';
            
            let content = `<strong>${node.title}</strong><br>`;
            content += `Success: ${node.successCount}<br>`;
            if (node.failureCount > 0) {
                content += `Failures: ${node.failureCount}<br>`;
                const total = node.successCount + node.failureCount;
                const rate = ((node.successCount / total) * 100).toFixed(1);
                content += `Success Rate: ${rate}%`;
            }
            
            tooltip.innerHTML = content;
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function setupPanZoom() {
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', pan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);
            canvas.addEventListener('wheel', zoom);
        }

        function startPan(e) {
            if (e.target.closest('.process-node-group')) return;
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY };
        }

        function pan(e) {
            if (!isPanning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            panOffset.x += dx;
            panOffset.y += dy;
            updateTransform();
            panStart = { x: e.clientX, y: e.clientY };
        }

        function endPan() {
            isPanning = false;
        }

        function zoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            currentZoom *= delta;
            currentZoom = Math.max(0.3, Math.min(3, currentZoom));
            updateZoomLevel();
            updateTransform();
        }

        function zoomIn() {
            currentZoom *= 1.2;
            currentZoom = Math.min(3, currentZoom);
            updateZoomLevel();
            updateTransform();
        }

        function zoomOut() {
            currentZoom *= 0.8;
            currentZoom = Math.max(0.3, currentZoom);
            updateZoomLevel();
            updateTransform();
        }

        function resetView() {
            currentZoom = 1;
            panOffset = { x: 0, y: 0 };
            updateZoomLevel();
            updateTransform();
        }

        function updateZoomLevel() {
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            const viewBox = `${-panOffset.x / currentZoom} ${-panOffset.y / currentZoom} ${1000 / currentZoom} ${800 / currentZoom}`;
            canvas.setAttribute('viewBox', viewBox);
        }

        function refreshData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('canvas').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            loadProcessData();
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('canvas').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex';
        }

        function showError(message) {
            document.getElementById('loading').innerHTML = `<div class="error">${message}</div>`;
        }
    </script>
</body>
</html>